/*
 * Copyright 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.alibaba.cloud.ai.dataagent.node;

import com.alibaba.cloud.ai.dataagent.common.connector.accessor.Accessor;
import com.alibaba.cloud.ai.dataagent.common.connector.bo.DbQueryParameter;
import com.alibaba.cloud.ai.dataagent.common.connector.bo.ResultSetBO;
import com.alibaba.cloud.ai.dataagent.common.connector.config.DbConfig;
import com.alibaba.cloud.ai.dataagent.constant.Constant;

import com.alibaba.cloud.ai.dataagent.dto.SqlRetryDto;
import com.alibaba.cloud.ai.dataagent.enums.TextType;
import com.alibaba.cloud.ai.dataagent.util.DatabaseUtil;
import com.alibaba.cloud.ai.graph.GraphResponse;
import com.alibaba.cloud.ai.graph.OverAllState;
import com.alibaba.cloud.ai.graph.action.NodeAction;
import com.alibaba.cloud.ai.graph.streaming.StreamingOutput;
import com.alibaba.cloud.ai.dataagent.util.ChatResponseUtil;
import com.alibaba.cloud.ai.dataagent.util.FluxUtil;
import com.alibaba.cloud.ai.dataagent.util.PlanProcessUtil;
import com.alibaba.cloud.ai.dataagent.util.StateUtil;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;

import java.util.HashMap;
import java.util.Map;

import static com.alibaba.cloud.ai.dataagent.constant.Constant.SQL_EXECUTE_NODE_OUTPUT;
import static com.alibaba.cloud.ai.dataagent.constant.Constant.SQL_GENERATE_OUTPUT;
import static com.alibaba.cloud.ai.dataagent.constant.Constant.SQL_REGENERATE_REASON;
import static com.alibaba.cloud.ai.dataagent.constant.Constant.SQL_RESULT_LIST_MEMORY;

/**
 * SQL execution node that executes SQL queries against the database.
 *
 * This node is responsible for: - Executing SQL queries generated by previous nodes -
 * Handling query results and errors - Providing streaming feedback to users during
 * execution - Managing step-by-step result accumulation
 *
 * @author zhangshenghang
 */
@Slf4j
@Component
@AllArgsConstructor
public class SqlExecuteNode implements NodeAction {

	private final DatabaseUtil databaseUtil;

	@Override
	public Map<String, Object> apply(OverAllState state) throws Exception {

		Integer currentStep = PlanProcessUtil.getCurrentStepNumber(state);

		String sqlQuery = StateUtil.getStringValue(state, SQL_GENERATE_OUTPUT);

		log.info("Executing SQL query: {}", sqlQuery);

		// Get the agent ID from the state
		String agentIdStr = StateUtil.getStringValue(state, Constant.AGENT_ID);
		if (agentIdStr == null || agentIdStr.trim().isEmpty()) {
			throw new IllegalStateException("Agent ID cannot be empty.");
		}

		Integer agentId = Integer.valueOf(agentIdStr);

		// Dynamically get the data source configuration for an agent
		DbConfig dbConfig = databaseUtil.getAgentDbConfig(agentId);

		return executeSqlQuery(state, currentStep, sqlQuery, dbConfig, agentId);
	}

	/**
	 * Executes the SQL query against the database and handles the results.
	 *
	 * This method follows the business-logic-first pattern: 1. Execute the actual SQL
	 * query immediately 2. Process and store the results 3. Create streaming output for
	 * user experience only
	 * @param state The overall state containing execution context
	 * @param currentStep The current step number in the execution plan
	 * @param sqlQuery The SQL query to execute
	 * @param dbConfig The database configuration to use for execution
	 * @param agentId The agent ID
	 * @return Map containing the generator for streaming output
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> executeSqlQuery(OverAllState state, Integer currentStep, String sqlQuery,
			DbConfig dbConfig, Integer agentId) {
		// Execute business logic first - actual SQL execution
		DbQueryParameter dbQueryParameter = new DbQueryParameter();
		dbQueryParameter.setSql(sqlQuery);
		dbQueryParameter.setSchema(dbConfig.getSchema());

		Accessor dbAccessor = databaseUtil.getAgentAccessor(agentId);
		final Map<String, Object> result = new HashMap<>();

		// 先返回流式数据，在执行数据库查询
		Flux<ChatResponse> displayFlux = Flux.create(emitter -> {
			emitter.next(ChatResponseUtil.createResponse("开始执行SQL..."));
			emitter.next(ChatResponseUtil.createResponse("执行SQL查询："));
			emitter.next(ChatResponseUtil.createPureResponse(TextType.SQL.getStartSign()));
			emitter.next(ChatResponseUtil.createResponse(sqlQuery));
			emitter.next(ChatResponseUtil.createPureResponse(TextType.SQL.getEndSign()));

			try {
				// Execute SQL query and get results immediately
				ResultSetBO resultSetBO = dbAccessor.executeSqlAndReturnObject(dbConfig, dbQueryParameter);
				String jsonStr = resultSetBO.toJsonStr();

				// 数据执行成功
				emitter.next(ChatResponseUtil.createResponse("执行SQL完成"));
				emitter.next(ChatResponseUtil.createResponse("SQL查询结果："));
				emitter.next(ChatResponseUtil.createPureResponse(TextType.RESULT_SET.getStartSign()));
				emitter.next(ChatResponseUtil.createPureResponse(jsonStr));
				emitter.next(ChatResponseUtil.createPureResponse(TextType.RESULT_SET.getEndSign()));

				// Update step results with the query output
				Map<String, String> existingResults = StateUtil.getObjectValue(state, SQL_EXECUTE_NODE_OUTPUT,
						Map.class, new HashMap<>());
				Map<String, String> updatedResults = PlanProcessUtil.addStepResult(existingResults, currentStep,
						jsonStr);

				log.info("SQL execution successful, result count: {}",
						resultSetBO.getData() != null ? resultSetBO.getData().size() : 0);

				// Prepare the final result object
				// Store List of SQL query results for use by code execution node
				result.putAll(Map.of(SQL_EXECUTE_NODE_OUTPUT, updatedResults, SQL_REGENERATE_REASON,
						SqlRetryDto.empty(), SQL_RESULT_LIST_MEMORY, resultSetBO.getData()));
			}
			catch (Exception e) {
				String errorMessage = e.getMessage();
				log.error("SQL execution failed - SQL: [{}] ", sqlQuery, e);
				result.put(SQL_REGENERATE_REASON, SqlRetryDto.sqlExecute(errorMessage));
				emitter.next(ChatResponseUtil.createResponse("SQL执行失败: " + errorMessage));
			}
			finally {
				emitter.complete();
			}
		});

		// Create generator using utility class, returning pre-computed business logic
		// result
		Flux<GraphResponse<StreamingOutput>> generator = FluxUtil.createStreamingGeneratorWithMessages(this.getClass(),
				state, v -> result, displayFlux);

		return Map.of(SQL_EXECUTE_NODE_OUTPUT, generator);
	}

}
